#!/bin/bash
# usage: run-nextclade-full --database=gisaid|genbank [--n_processors] [--n_nextclade_threads] [--batch_size]
#        run-nextclade-full --help
#
# Make a full Nextclade run, recomputing clades and other metrics
# for all sequences. This is necessary every time when new clades are defined or
# when upgrading to the new version of Nextclade with breaking changes.
#
# Implementation details: sequence data is split into batches of given size.
# A number of Nextclade instances is launched concurrently, depending on
# given number of processors and number of threads each instance is allowed to
#
#
# Note: this might take very long time to run (hours to days), depending on
# number of sequences to be processed and available computational resources.
#
# --database=gisaid|genbank   Database to use. This defines which sequences will
#                             be downloaded and where the results will be
#                             uploaded.
#
# --n_processors              Maximum number of threads all instances of
#                             Nextclade are allowed to use.
#
# --n_nextclade_threads       Maximum number of threads each individual instance
#                             of Nextclade is allowed to use
#
# --batch_size                Maximum number of sequences fed to an individual
#                             instance of Nextclade
set -euo pipefail

main() {
  # Total number of processors in the system that Nextclade can use.
  # Default equals to the number of threads on all CPUs combined.
  N_PROCESSORS=${N_PROCESSORS:-$(getconf _NPROCESSORS_ONLN)}

  # Each invocation of Nextclade will use this number of threads
  N_NEXTCLADE_THREADS=${N_NEXTCLADE_THREADS:-8}

  # Each invocation of Nextclade will be given this number of sequences
  BATCH_SIZE=${BATCH_SIZE:-100000}

  DATABASE=

  silent=0

  for arg; do
    case "$arg" in
    -h | --help)
      print-help
      exit
      ;;
    --database=*)
      DATABASE="${arg#*=}"
      shift
      ;;
    --n_processors=*)
      N_PROCESSORS="${arg#*=}"
      shift
      ;;
    --n_nextclade_threads=*)
      N_NEXTCLADE_THREADS="${arg#*=}"
      shift
      ;;
    --batch_size=*)
      BATCH_SIZE="${arg#*=}"
      shift
      ;;
    esac
  done

  if [ "${DATABASE}" == "gisaid" ]; then
    S3_SRC="s3://nextstrain-ncov-private"
  elif [ "${DATABASE}" == "genbank" ]; then
    S3_SRC="s3://nextstrain-data/files/ncov/open"
  else
    echo "[ERROR] ${0}:${LINENO}: Unknown database: The '--database' flag should be set to either 'gisaid' or 'genbank'"
    exit 1
  fi

  S3_DST="$S3_SRC/nextclade-full-run"

  INPUT_FASTA="data/${DATABASE}/sequences.fasta"
  OUTPUT_TSV="data/${DATABASE}/nextclade.tsv"
  TMP_DIR_FASTA="tmp/${DATABASE}/fasta"
  TMP_DIR_TSV="tmp/${DATABASE}/clades"
  TMP_DIR_NEXTCLADE_DATASET="tmp/dataset"
  TMP_DIR_UNUSED="tmp/${DATABASE}/unused"
  INPUT_WILDCARD="${TMP_DIR_FASTA}/*.fasta"
  OUTPUT_WILDCARD="${TMP_DIR_TSV}/*.tsv"

  NEXTCLADE_BIN_URL="https://github.com/nextstrain/nextclade/releases/latest/download/nextclade-Linux-x86_64"
  NEXTCLADE_BIN="nextclade"

  # Maximum number of Nextclade invocations that can run concurrently
  N_CONCURRENT_JOBS_MAX=$((N_PROCESSORS / N_NEXTCLADE_THREADS + 1))
  if [ $N_CONCURRENT_JOBS_MAX == 0 ]; then
    N_CONCURRENT_JOBS_MAX=1
  fi

  echo "[ INFO] ${0}:${LINENO}: Nextclade full run is starting"
  echo "[ INFO] ${0}:${LINENO}:   DATABASE=${DATABASE}"
  echo "[ INFO] ${0}:${LINENO}:   N_PROCESSORS=${N_PROCESSORS}"
  echo "[ INFO] ${0}:${LINENO}:   N_NEXTCLADE_THREADS=${N_NEXTCLADE_THREADS}"
  echo "[ INFO] ${0}:${LINENO}:   N_CONCURRENT_JOBS_MAX=${N_CONCURRENT_JOBS_MAX}"
  echo "[ INFO] ${0}:${LINENO}:   BATCH_SIZE=${BATCH_SIZE}"
  echo "[ INFO] ${0}:${LINENO}:   S3_SRC=${S3_SRC}"
  echo "[ INFO] ${0}:${LINENO}:   S3_DST=${S3_DST}"
  echo "[ INFO] ${0}:${LINENO}:   NEXTCLADE_BIN_URL=${NEXTCLADE_BIN_URL}"

  echo "[ INFO] ${0}:${LINENO}: Downloading latest Nextclade version from '${NEXTCLADE_BIN_URL}' to '${NEXTCLADE_BIN}'"
  curl -fsSL ${NEXTCLADE_BIN_URL} -o "${NEXTCLADE_BIN}"
  chmod +x "${NEXTCLADE_BIN}"

  echo "[ INFO] ${0}:${LINENO}: Downloading '${S3_SRC}/sequences.fasta.xz' to '${INPUT_FASTA}'"
  aws s3 cp --no-progress "${S3_SRC}/sequences.fasta.xz" - | xz -T0 -cdfq >"${INPUT_FASTA}"

  echo "[ INFO] ${0}:${LINENO}: Splitting '${INPUT_FASTA}' into batches of size ${BATCH_SIZE} sequences and storing them in '${INPUT_WILDCARD}'"
  # Split fasta file to multiple batches
  mkdir -p "${TMP_DIR_FASTA}"
  ./bin/split-fasta \
    "${INPUT_FASTA}" \
    --batch_size="${BATCH_SIZE}" \
    --output_dir="${TMP_DIR_FASTA}"

  # Check if batches exist and report
  if ls ${INPUT_WILDCARD} 1>/dev/null 2>&1; then
    NUM_BATCHES="$(ls -Ubad1 -- ${INPUT_WILDCARD} 2>/dev/null | wc -l)"
    echo "[ INFO] ${0}:${LINENO}: There are now ${NUM_BATCHES} batches of sequences to process with Nextclade (batch size is ${BATCH_SIZE})"
  else
    echo "[ INFO] ${0}:${LINENO}: There are no sequences to process. Skipping Nextclade step."
    rm -rf "${TMP_DIR_FASTA}"
    exit 0
  fi

  if ! command -v ./${NEXTCLADE_BIN} &>/dev/null; then
    echo "[ERROR] ${0}:${LINENO}: Nextclade executable not found"
    exit 1
  fi

  NEXTCLADE_VERSION="$(./${NEXTCLADE_BIN} --version)"
  echo "[ INFO] ${0}:${LINENO}: Nextclade version: ${NEXTCLADE_VERSION}"

  echo "[ INFO] ${0}:${LINENO}: Downloading Nextclade dataset \"sars-cov-2\""
  ./${NEXTCLADE_BIN} dataset get --name="sars-cov-2" --output-dir="${TMP_DIR_NEXTCLADE_DATASET}" --verbose

  # Run batches in parallel
  echo "[ INFO] ${0}:${LINENO}: Nextclade is allowed to use ${N_PROCESSORS} threads. Each invocation of Nextclade is allowed to use ${N_NEXTCLADE_THREADS} threads."
  echo "[ INFO] ${0}:${LINENO}: Will run ${NUM_BATCHES} total Nextclade jobs, at most ${N_CONCURRENT_JOBS_MAX} concurrent jobs at a time."
  mkdir -p "${TMP_DIR_TSV}"
  N_JOBS_CURRENT="\j"
  for input in ${INPUT_WILDCARD}; do
    if [ ! -e "${input}" ]; then
      # If ${input} does not exist, this means that INPUT_WILDCARD was not expanded,
      # there are no batch files and we should not attempt to run the processing.
      # If we would, then it will crash.
      break
    fi

    input_basename="$(basename "${input}")"
    output_basename="${input_basename%.fasta}.tsv"
    output_filename="${TMP_DIR_TSV}/${output_basename}"

    # Wait until there is an empty job slot to run. This is to avoid oversubscription.
    while ((${N_JOBS_CURRENT@P} >= $N_CONCURRENT_JOBS_MAX)); do
      wait -n
    done

    echo "[ INFO] ${0}:${LINENO}: Running Nextclade for batch ${input} as a background job"
    ./${NEXTCLADE_BIN} run \
      --jobs="${N_NEXTCLADE_THREADS}" \
      --in-order \
      --verbosity=error \
      --input-fasta="${input}" \
      --input-dataset="${TMP_DIR_NEXTCLADE_DATASET}" \
      --output-tsv="${output_filename}" \
      --genes=E,M,N,ORF1a,ORF1b,ORF3a,ORF6,ORF7a,ORF7b,ORF8,ORF9b,S \
      --output-dir="${TMP_DIR_UNUSED}" \
      --output-basename="nextclade" \
      &
  done

  for job in $(jobs -p); do
    echo "[ INFO] ${0}:${LINENO}: Waiting until all Nextclade background jobs finish"
    wait $job
  done

  # Check if output batches exist and report
  if ls ${OUTPUT_WILDCARD} 1>/dev/null 2>&1; then
    NUM_OUTPUT_BATCHES="$(ls -Ubad1 -- ${OUTPUT_WILDCARD} 2>/dev/null | wc -l)"
    echo "[ INFO] ${0}:${LINENO}: There are now ${NUM_OUTPUT_BATCHES} output batches to concatenate (batch size is ${BATCH_SIZE})"
    echo "[ INFO] ${0}:${LINENO}: Concatenating Nextclade output batches from '${OUTPUT_WILDCARD}' into '${OUTPUT_TSV}'"
    for output in ${OUTPUT_WILDCARD}; do
      ./bin/join-rows "$output" "${OUTPUT_TSV}" -o "${OUTPUT_TSV}"
    done
  else
    echo "[ERROR] ${0}:${LINENO}: Output batches are not found: '${OUTPUT_WILDCARD}'. Nextclade jobs mush have failed to write their results."
    exit 1
  fi

  # Check if output batches exist and report
  if ! ls ${OUTPUT_TSV} 1>/dev/null 2>&1; then
    echo "[ERROR] ${0}:${LINENO}: Concatenated result not found: '${OUTPUT_TSV}'. Concatenation of output batches must have failed."
    exit 1
  fi

  ./bin/upload-to-s3 ${silent:+--quiet} "${OUTPUT_TSV}" "$S3_DST/nextclade.tsv.gz"
}

print-help() {
  # Print the help comments at the top of this file ($0)
  local line
  while read -r line; do
    if [[ $line =~ ^#! ]]; then
      continue
    elif [[ $line =~ ^# ]]; then
      line="${line/##/}"
      line="${line/# /}"
      echo "$line"
    else
      break
    fi
  done <"$0"
}

main "$@"
